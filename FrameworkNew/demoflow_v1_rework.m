clear all;addpath('mex');%Frames must be named correctly. Starting : 1.jpg for LDR frames and 1.exr%for HDR frames. If there is an additional filename before, add the name in the preFilename string. %If you want to use .hdr files you have to change hdrExtension to ".hdr." %Generated files are currently called CreatedHDR_X.hdr and the tonemapped%version is called CreatedHDRTonemapped_X.jpghdrExtension = ".hdr";ldrExtension = ".jpg";hdrFilename = "CreatedHDR_pano";ldrFilename = "CreatedHDRTonemapped_pano";preFilename = "pano";% load the framesfor cnt=1:100    tmp = sprintf('%s%d%s',preFilename,cnt,hdrExtension);%fitting fileending needed, like .hdr    tmpL = sprintf('%s%d%s',preFilename,cnt,ldrExtension);    if ~isfile(tmpL)        amount = cnt-1;        break;    end    LdrA.(sprintf('L_%d', cnt))=hdrimread(tmpL);    if isfile(tmp)     % File exists.     lastHdrEqualLdr = cnt;     HdrA.(sprintf('H_%d', cnt))=hdrimread(tmp);    else     HdrA.(sprintf('H_%d', cnt))=0;     lastHdr = cnt-1;    endend% set optical flow parameters (see Coarse2FineTwoFrames.m for the definition of the parameters)alpha = 0.012;ratio = 0.75;minWidth = 20;nOuterFPIterations = 7;nInnerFPIterations = 1;nSORIterations = 30;para = [alpha,ratio,minWidth,nOuterFPIterations,nInnerFPIterations,nSORIterations];%LdrStack=zeros(amount);for count=1:amount        tmpC = sprintf('HdrA.H_%d',count);    tmpD = sprintf('LdrA.L_%d',count);    imag1 = eval(tmpC);%access struct element    LdrStack{count} = eval(tmpD);    %LdrStack(count,:,:,:) = eval(tmpD);    if imag1~=0     if ~exist('firstHdr','var')        firstHdr = imag1;        firstHdrIdx = count;     elseif ~exist('secondHdr','var')        secondHdr = imag1;        secondHdrIdx = count;        doFlowCalculation(firstHdr,secondHdr,LdrStack, firstHdrIdx, secondHdrIdx,para, hdrFilename, ldrFilename);       firstHdr =secondHdr;       firstHdrIdx = secondHdrIdx;       clear secondHdr;     %  clear LdrStack;     end    endendfunction [cost_mat] = smoothCostGrad(s1r,s1g,s1b,s2r,s2g,s2b,t1r,t1g,t1b,t2r,t2g,t2b)	gradTextR  = abs( s1r - t1r );	gradTextV  = abs( s1g - t1g );	gradTextB  = abs( s1b - t1b );	gradPatchR  = abs( s2r - t2r );	gradPatchV  = abs( s2g - t2g );	gradPatchB  = abs( s2b - t2b );	grad = ((gradTextR + gradTextV + gradTextB) / 3.0 )+ (( gradPatchR + gradPatchV + gradPatchB ) / 3.0);	grad= grad +1.0; % to avoid zero division     %smoothCostBasic    cr = abs( s1r - s2r ) +  abs( t1r - t2r );	cg = abs( s1g - s2g ) +  abs( t1g - t2g );	cb = abs( s1b - s2b ) +  abs( t1b - t2b );	tmp =( ( cr + cg + cb ) / 3.0 );    	cost_mat = (tmp/ sqrt(grad));  end    function [] =doFlowCalculation(firstHdr,secondHdr,LdrStack, firstHdrIdx, secondHdrIdx,para, hdrFilename, ldrFilename)   maximumLDR =size(LdrStack,2);%amount LDR frames    %maximumLDR =size(LdrStack,1);%amount LDR frames    for idx=firstHdrIdx:maximumLDR-2%max already HDR so-1    [vx,vy,~] = Coarse2FineTwoFrames(LdrStack{idx},LdrStack{idx+1},para);%fwd    %[vx,vy,~] = Coarse2FineTwoFrames(LdrStack(idx,:,:,:),LdrStack(idx+1,:,:,:),para);%fwd	vx_2 = vx;	vy_2 = vy;    clear vx;    clear vy;	bwdidx = 1;%idx;	%while (bwdidx+1)~=(maximumLDR-bwdidx)	  while ((bwdidx)<(maximumLDR-bwdidx))&&((maximumLDR-bwdidx)>(firstHdrIdx))  	  [vxb,vyb,~] = Coarse2FineTwoFrames(LdrStack{maximumLDR+1-bwdidx},LdrStack{maximumLDR-bwdidx},para);%bwd     % [vxb,vyb,~] = Coarse2FineTwoFrames(LdrStack(maximumLDR+1-bwdidx,:,:,:),LdrStack(maximumLDR-bwdidx,:,:,:),para);%bwd	  vxb_2 = vxb;	  vyb_2 = vyb;         clear vxb;         clear vyb;	  bwdidx = bwdidx+1;	  end    [FWDImage, BWDImage, moco_bwd, moco_fwd] =createHDR(firstHdr, secondHdr ,vx_2,vy_2,vxb_2,vyb_2);    doGraphCut(FWDImage, BWDImage, moco_bwd, moco_fwd, firstHdrIdx, secondHdrIdx, LdrStack{idx+1}, idx+1, hdrFilename, ldrFilename);    %doGraphCut(FWDImage, BWDImage, moco_bwd, moco_fwd, firstHdrIdx, secondHdrIdx, LdrStack(idx+1,:,:,:), idx+1);   endendfunction [FWDImage, BWDImage, moco_fwd, moco_bwd] =createHDR(leftHdr, rightHdr,vx_1,vy_1,vxb_1,vyb_1)	[x, y] = meshgrid(1:size(leftHdr,2), 1:size(leftHdr,1));	redChannel = leftHdr(:, :, 1);	DR = interp2(redChannel, x-vx_1, y-vy_1);	greenChannel = leftHdr(:, :, 2);	DG = interp2(greenChannel, x-vx_1, y-vy_1);	blueChannel = leftHdr(:, :, 3);	DB = interp2(blueChannel, x-vx_1, y-vy_1);	FWDImage = cat(3, DR, DG, DB);	%hdrimwrite(FWDImage, 'resultExtraFWD10.hdr');	[moco_fwd] = calculateMoCo(FWDImage, vx_1,vy_1);	[x, y] = meshgrid(1:size(rightHdr,2), 1:size(rightHdr,1));	redChannel = rightHdr(:, :, 1);	DR = interp2(redChannel, x-vxb_1, y-vyb_1);	greenChannel = rightHdr(:, :, 2);	DG = interp2(greenChannel, x-vxb_1, y-vyb_1);	blueChannel = rightHdr(:, :, 3);	DB = interp2(blueChannel, x-vxb_1, y-vyb_1);	BWDImage = cat(3, DR, DG, DB);	%hdrimwrite(BWDImage, 'resultExtraBWD10.hdr');	[moco_bwd] = calculateMoCo(BWDImage, vxb_1,vyb_1);endfunction [moco] =calculateMoCo(HdrImage, vx,vy)	clear flow;	flow(:,:,1) = vx;	flow(:,:,2) = vy;		meanImage = imfilter(flow, ones(3)/9);%mean	sz = size(HdrImage);	tmpMoco = zeros(sz(1:2),'double');	for rows=1:size(meanImage,1)  	  for cols=1:size(meanImage,2)    	    first_angle= atan(HdrImage(rows,cols,1)/HdrImage(rows,cols,2));     	    sec_angle= atan(meanImage(rows,cols,1)/meanImage(rows,cols,2));      	    angle = first_angle-sec_angle;     	    if (angle > 180)       	     angle = angle-360;       	    elseif (angle <-180)       	     angle = angle+360;      	    end    	    tmpMoco(rows,cols)= angle;%bwd   	  end	end	moco = tmpMoco;endfunction [] =doGraphCut(FWDImage, BWDImage, moco_bwd, moco_fwd, firstHdrIdx, secondHdrIdx, LdrFrame, ldrIdx, hdrFilename, ldrFilename)    wlImage = FWDImage;%forw image    fi = LdrFrame;%simulated LDR frame    wrImage = BWDImage;%backw image    wlImageTone = tonemap(wlImage);%forw image tonemapped    wrImageTone = tonemap(wrImage);%backw image tonemapped    motion_conf_bwd = moco_bwd;    motion_conf_fwd = moco_fwd;    frame_index_wl = firstHdrIdx;    frame_index_fi = ldrIdx;    frame_index_wr = secondHdrIdx;    k = 3;%# different labels    sz = size(fi);    Dc_new = zeros([sz(1:2) k],'single');    %Datacost function    for rows=1:size(fi,1)     for cols=1:size(fi,2)      eukl = double(wlImageTone(rows,cols) - fi(rows,cols));      Dc_2 = norm(eukl);      Df = motion_conf_fwd(rows,cols);      Dd = abs(frame_index_wl-frame_index_fi) / abs(frame_index_wr-frame_index_wl);      Dc_new(rows,cols,1)=Dc_2+Df+Dd;      Df = motion_conf_bwd(rows,cols);      eukl = double(wrImageTone(rows,cols) - fi(rows,cols));      Dc_2 = norm(eukl);      Dd = abs(frame_index_wr-frame_index_fi) / abs(frame_index_wr-frame_index_wl);      Dc_new(rows,cols,3)=Dc_2+Df+Dd;      Dc_new(rows,cols,2) = 500;%0.3 originally     end    end    %smoothness function    Sc_new = [1,1,1;1,1,1;1,1,1];    Hc_new = zeros(sz(1:2),'single');%horizontal cost    Vc_new = zeros(sz(1:2),'single');%vertical cost	for rows=1:size(fi,1)     for cols=1:size(fi,2)        if (cols-1)<=0            Hc_new(rows,cols)= 99999;%inf;        else        	Hc_new(rows,cols)= smoothCostGrad( wlImage(rows,cols,1), wlImage(rows,cols,2), wlImage(rows,cols,3),wrImage(rows,cols,1),wrImage(rows,cols,2),wrImage(rows,cols,3),wlImage(rows,cols-1,1), wlImage(rows,cols-1,2), wlImage(rows,cols-1,3),wrImage(rows,cols-1,1),wrImage(rows,cols-1,2),wrImage(rows,cols-1,3));         end        if (rows-1)<=0            Vc_new(rows,cols)= 99999;%inf;        else        	Vc_new(rows,cols)= smoothCostGrad( wlImage(rows,cols,1), wlImage(rows,cols,2), wlImage(rows,cols,3),wrImage(rows,cols,1),wrImage(rows,cols,2),wrImage(rows,cols,3),wlImage(rows-1,cols,1), wlImage(rows-1,cols,2), wlImage(rows-1,cols,3),wrImage(rows-1,cols,1),wrImage(rows-1,cols,2),wrImage(rows-1,cols,3));        end    %TODO: maybe use at edges    %        if (cols+1)>size(fi,2)    %        	Hc_new(rows,cols)= Hc_new(rows,cols)+ inf;    %        else    %            Hc_new(rows,cols)= Hc_new(rows,cols)+smoothCostGrad( wlImage(rows,cols,1), wlImage(rows,cols,2), wlImage(rows,cols,3),wrImage(rows,cols,1),wrImage(rows,cols,2),wrImage(rows,cols,3),wlImage(rows,cols+1,1), wlImage(rows,cols+1,2), wlImage(rows,cols+1,3),wrImage(rows,cols+1,1),wrImage(rows,cols+1,2),wrImage(rows,cols+1,3));    %        end    %        if (rows+1)>size(fi,1)    %        	Vc_new(rows,cols)= Vc_new(rows,cols)+inf;    %        else    %        	Vc_new(rows,cols)= Vc_new(rows,cols)+smoothCostGrad( wlImage(rows,cols,1), wlImage(rows,cols,2), wlImage(rows,cols,3),wrImage(rows,cols,1),wrImage(rows,cols,2),wrImage(rows,cols,3),wlImage(rows+1,cols,1), wlImage(rows+1,cols,2), wlImage(rows+1,cols,3),wrImage(rows+1,cols,1),wrImage(rows+1,cols,2),wrImage(rows+1,cols,3));    %        end     end	end    %graphcut    gch = GraphCut('open', Dc_new, Sc_new, Vc_new, Hc_new);    [gch L] = GraphCut('expand',gch); %labels from 0 to (labels-1)- so 0,1,2 here    [gch se de] = GraphCut('energy', gch)    [gch e] = GraphCut('energy', gch)    [gch L] = GraphCut('swap', gch);    gch = GraphCut('close', gch);    mix = zeros([sz(1:2) k],'double');    for rows=1:size(Dc_new,1)     for cols=1:size(Dc_new,2)        if (Dc_new(rows,cols,1)<Dc_new(rows,cols,2))&&(Dc_new(rows,cols,1)<Dc_new(rows,cols,3))           mix(rows,cols,:)= wlImage(rows,cols,:);        elseif (Dc_new(rows,cols,3)<Dc_new(rows,cols,2))&&(Dc_new(rows,cols,3)<Dc_new(rows,cols,1))            mix(rows,cols,:)= wrImage(rows,cols,:);        else            mix(rows,cols,:)= fi(rows,cols,:);        end     end    end    rgb = tonemap(mix);    hdrfname = sprintf ( '%s%d.hdr', hdrFilename, ldrIdx );    ldrfname = sprintf ( '%s%d.jpg', ldrFilename, ldrIdx );    imwrite(rgb, ldrfname);    hdrimwrite(mix, hdrfname);end%end